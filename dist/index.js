var D;(x=>{function h(f,i){let n=i-f;if(n===0)return 0;let e=Math.floor((n- -Math.PI)/(Math.PI*2));return n-e*(Math.PI*2)}x.shortestBetween=h;function a(f){return f=f%(2*Math.PI),f>=0?f:f+2*Math.PI}x.normalize=a})(D||={});var p;(M=>{function h({x:r,y:t},o){return{x:r+o.x,y:t+o.y}}M.offsetPoint=h;function a(r,t,o){return o?(o.x=r.x*t,o.y=r.y*t,o):{x:r.x*t,y:r.y*t}}M.mult=a;function x(r,t){return t?(t.x=Math.floor(r.x),t.y=Math.floor(r.y),t):{x:Math.floor(r.x),y:Math.floor(r.y)}}M.floor=x;function f(r,t){return t?(t.x=Math.round(r.x),t.y=Math.round(r.y),t):{x:Math.round(r.x),y:Math.round(r.y)}}M.round=f;function i(r,t){return t?(t.x=Math.ceil(r.x),t.y=Math.ceil(r.y),t):{x:Math.ceil(r.x),y:Math.ceil(r.y)}}M.ceil=i;function n(r,t,o){return o?(o.x=r.x+t.x,o.y=r.y+t.y,o):{x:r.x+t.x,y:r.y+t.y}}M.add=n;function e(r,t){let o=t.x-r.x,s=t.y-r.y;return Math.sqrt(s*s+o*o)}M.distance=e;function c(r,t){return r.x==t.x&&r.y==t.y}M.equals=c;function l(r){return{x:r.x,y:r.y}}M.clone=l})(p||={});var g;(M=>{function h(r){return{x:Math.floor((r.from.x+r.to.x)/2),y:Math.floor((r.from.y+r.to.y)/2)}}M.center=h;function a(r){return{x:r.to.x-r.from.x+1,y:r.to.y-r.from.y+1}}M.size=a;function x(r,t){return r.from.x<=t.x&&t.x<=r.to.x&&r.from.y<=t.y&&t.y<=r.to.y}M.containsPoint=x;function f({x:r,y:t},o,s){return s?(s.from.x=o.from.x+r,s.from.y=o.from.y+t,s.to.x=o.to.x+r,s.to.y=o.to.y+t,s):{from:{x:o.from.x+r,y:o.from.y+t},to:{x:o.to.x+r,y:o.to.y+t}}}M.offsetArea=f;function i(r,t){return p.equals(r.from,t.from)&&p.equals(r.to,t.to)}M.equals=i;function n(r){return{from:{x:r.from.x,y:r.from.y},to:{x:r.to.x,y:r.to.y}}}M.clone=n;function e(r,t,o=1){for(let s=r.from.x;s<=r.to.x;s+=o)for(let d=r.from.y;d<=r.to.y;d+=o)t(s,d)}M.forEach=e;function c(r={x:0,y:0},t={x:0,y:0}){if(r.x>t.x||r.y>t.y)throw new Error("from must be smaller than to");return{from:r,to:t}}M.mk=c;function l(r){return(r.to.x-r.from.x+1)*(r.to.y-r.from.y+1)}M.computeSurfaceArea=l})(g||={});var m="up",y="down",u="right",P="left";var w;(x=>{function h(f){switch(f){case m:return y;case y:return m;case u:return P;case P:return u}throw new Error}x.reverse=h;function a(f){switch(f){case m:return u;case y:return P;case u:return y;case P:return m}throw new Error}x.getAdjacentRightDir=a})(w||={});var I;(a=>{function h(x){return Math.round(x)}a.roundToInt=h})(I||={});var R;(f=>{function h(i,n,{x:e,y:c}={x:0,y:0}){switch(i){case m:return{x:e,y:c-n};case y:return{x:e,y:c+n};case u:return{x:e+n,y:c};case P:return{x:e-n,y:c}}throw new Error}f.addInDirection=h;function a({x:i,y:n},e=1){let c=[];return c.push({direction:m,point:h(m,e,{x:i,y:n})}),c.push({direction:u,point:h(u,e,{x:i,y:n})}),c.push({direction:y,point:h(y,e,{x:i,y:n})}),c.push({direction:P,point:h(P,e,{x:i,y:n})}),c}f.get4AdjacentDirectionPoint=a;function x({x:i,y:n},e){switch(e){case m:return{x:i,y:n};case y:return{x:-i,y:-n};case u:return{x:-n,y:i};case P:return{x:n,y:-i}}throw new Error}f.rotatePoint=x})(R||={});var A;(a=>{function h(x,f,i){let n=Math.cos(f),e=Math.sin(f),c,l;if(i){let M=i.x,r=i.y;c=n*(x.x-M)-e*(x.y-r),l=e*(x.x-M)+n*(x.y-r)}else c=n*x.x-e*x.y,l=e*x.x+n*x.y;return x.x=c,x.y=l,x}a.rotate=h})(A||={});export{D as AngleRadMath,g as AreaMath,y as DOWN,w as DirectionMath,I as IntMath,P as LEFT,p as Point2Math,R as PointDirectionMath,u as RIGHT,m as UP,A as Vector2Math};
//# sourceMappingURL=index.js.map