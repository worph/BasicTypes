var g=Object.defineProperty;var T=Object.getOwnPropertyDescriptor;var V=Object.getOwnPropertyNames;var q=Object.prototype.hasOwnProperty;var F=(c,s)=>{for(var i in s)g(c,i,{get:s[i],enumerable:!0})},G=(c,s,i,x)=>{if(s&&typeof s=="object"||typeof s=="function")for(let n of V(s))!q.call(c,n)&&n!==i&&g(c,n,{get:()=>s[n],enumerable:!(x=T(s,n))||x.enumerable});return c};var H=c=>G(g({},"__esModule",{value:!0}),c);var L={};F(L,{AngleRadMath:()=>w,AreaMath:()=>I,DOWN:()=>P,DirectionMath:()=>A,IntMath:()=>R,LEFT:()=>a,Point2Math:()=>p,PointDirectionMath:()=>b,RIGHT:()=>h,UP:()=>u,Vector2Math:()=>E});module.exports=H(L);var w;(i=>{function c(x,n){let e=n-x;if(e===0)return 0;let f=Math.floor((e- -Math.PI)/(Math.PI*2));return e-f*(Math.PI*2)}i.shortestBetween=c;function s(x){return x=x%(2*Math.PI),x>=0?x:x+2*Math.PI}i.normalize=s})(w||={});var p;(M=>{function c({x:t,y:r},o){return{x:t+o.x,y:r+o.y}}M.offsetPoint=c;function s(t,r,o){return o?(o.x=t.x*r,o.y=t.y*r,o):{x:t.x*r,y:t.y*r}}M.mult=s;function i(t,r){return r?(r.x=Math.floor(t.x),r.y=Math.floor(t.y),r):{x:Math.floor(t.x),y:Math.floor(t.y)}}M.floor=i;function x(t,r){return r?(r.x=Math.round(t.x),r.y=Math.round(t.y),r):{x:Math.round(t.x),y:Math.round(t.y)}}M.round=x;function n(t,r){return r?(r.x=Math.ceil(t.x),r.y=Math.ceil(t.y),r):{x:Math.ceil(t.x),y:Math.ceil(t.y)}}M.ceil=n;function e(t,r,o){return o?(o.x=t.x+r.x,o.y=t.y+r.y,o):{x:t.x+r.x,y:t.y+r.y}}M.add=e;function f(t,r){let o=r.x-t.x,y=r.y-t.y;return Math.sqrt(y*y+o*o)}M.distance=f;function m(t,r){return t.x==r.x&&t.y==r.y}M.equals=m;function d(t){return{x:t.x,y:t.y}}M.clone=d})(p||={});var I;(t=>{function c(r){return r.to.x>=r.from.x&&r.to.y>=r.from.y}t.isValid=c;function s(r){return{x:Math.floor((r.from.x+r.to.x)/2),y:Math.floor((r.from.y+r.to.y)/2)}}t.center=s;function i(r){return{x:r.to.x-r.from.x+1,y:r.to.y-r.from.y+1}}t.size=i;function x(r,o){return r.from.x<=o.x&&o.x<=r.to.x&&r.from.y<=o.y&&o.y<=r.to.y}t.containsPoint=x;function n({x:r,y:o},y,l){return l?(l.from.x=y.from.x+r,l.from.y=y.from.y+o,l.to.x=y.to.x+r,l.to.y=y.to.y+o,l):{from:{x:y.from.x+r,y:y.from.y+o},to:{x:y.to.x+r,y:y.to.y+o}}}t.offsetArea=n;function e(r,o){return p.equals(r.from,o.from)&&p.equals(r.to,o.to)}t.equals=e;function f(r){return{from:{x:r.from.x,y:r.from.y},to:{x:r.to.x,y:r.to.y}}}t.clone=f;function m(r,o,y=1){for(let l=r.from.x;l<=r.to.x;l+=y)for(let D=r.from.y;D<=r.to.y;D+=y)o(l,D)}t.forEach=m;function d(r={x:0,y:0},o={x:0,y:0}){if(r.x>o.x||r.y>o.y)throw new Error("from must be smaller than to");return{from:r,to:o}}t.mk=d;function M(r){return(r.to.x-r.from.x+1)*(r.to.y-r.from.y+1)}t.computeSurfaceArea=M})(I||={});var u="up",P="down",h="right",a="left";var A;(i=>{function c(x){switch(x){case u:return P;case P:return u;case h:return a;case a:return h}throw new Error}i.reverse=c;function s(x){switch(x){case u:return h;case P:return a;case h:return P;case a:return u}throw new Error}i.getAdjacentRightDir=s})(A||={});var R;(s=>{function c(i){return Math.round(i)}s.roundToInt=c})(R||={});var b;(x=>{function c(n,e,{x:f,y:m}={x:0,y:0}){switch(n){case u:return{x:f,y:m-e};case P:return{x:f,y:m+e};case h:return{x:f+e,y:m};case a:return{x:f-e,y:m}}throw new Error}x.addInDirection=c;function s({x:n,y:e},f=1){let m=[];return m.push({direction:u,point:c(u,f,{x:n,y:e})}),m.push({direction:h,point:c(h,f,{x:n,y:e})}),m.push({direction:P,point:c(P,f,{x:n,y:e})}),m.push({direction:a,point:c(a,f,{x:n,y:e})}),m}x.get4AdjacentDirectionPoint=s;function i({x:n,y:e},f){switch(f){case u:return{x:n,y:e};case P:return{x:-n,y:-e};case h:return{x:-e,y:n};case a:return{x:e,y:-n}}throw new Error}x.rotatePoint=i})(b||={});var E;(s=>{function c(i,x,n){let e=Math.cos(x),f=Math.sin(x),m,d;if(n){let M=n.x,t=n.y;m=e*(i.x-M)-f*(i.y-t),d=f*(i.x-M)+e*(i.y-t)}else m=e*i.x-f*i.y,d=f*i.x+e*i.y;return i.x=m,i.y=d,i}s.rotate=c})(E||={});0&&(module.exports={AngleRadMath,AreaMath,DOWN,DirectionMath,IntMath,LEFT,Point2Math,PointDirectionMath,RIGHT,UP,Vector2Math});
//# sourceMappingURL=index.cjs.map