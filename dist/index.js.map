{"version":3,"sources":["../src/AngleRadMath.ts","../src/Point2Math.ts","../src/AreaMath.ts","../src/Direction.ts","../src/DirectionMath.ts","../src/IntMath.ts","../src/PointDirectionMath.ts","../src/Vector2Math.ts"],"sourcesContent":["//https://github.com/photonstorm/phaser/tree/v3.55.2/src/math/angle\r\nimport {AngleRad} from \"./AngleRad\";\r\n\r\nexport namespace AngleRadMath {\r\n    /**\r\n     * Gets the shortest angle between `angle1` and `angle2`.\r\n     *\r\n     * Both angles must be in the range -180 to 180, which is the same clamped\r\n     * range that `sprite.angle` uses, so you can pass in two sprite angles to\r\n     * this method and get the shortest angle back between the two of them.\r\n     *\r\n     * The angle returned will be in the same range. If the returned angle is\r\n     * greater than 0 then it's a counter-clockwise rotation, if < 0 then it's\r\n     * a clockwise rotation.\r\n     * @param angleFrom range from -Math.Pi to Pi\r\n     * @param angleTo range from -Math.Pi to Pi\r\n     */\r\n    export function shortestBetween(angleFrom: AngleRad, angleTo: AngleRad) {\r\n        //https://github.com/photonstorm/phaser/blob/v3.55.2/src/math/angle/ShortestBetween.js\r\n        let difference = angleTo - angleFrom;\r\n\r\n        if (difference === 0) {\r\n            return 0;\r\n        }\r\n\r\n        let times = Math.floor((difference - (-Math.PI)) / (Math.PI * 2));\r\n\r\n        return difference - (times * (Math.PI * 2));\r\n    }\r\n\r\n    /**\r\n     * Normalize an angle to the [0, 2pi] range.\r\n     *\r\n     * @function Phaser.Math.Angle.Normalize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} angle - The angle to normalize, in radians.\r\n     *\r\n     * @return {number} The normalized angle, in radians.\r\n     */\r\n    export function normalize(angle: AngleRad): AngleRad {\r\n        //https://github.com/photonstorm/phaser/blob/v3.55.2/src/math/angle/Normalize.js\r\n        angle = angle % (2 * Math.PI);\r\n\r\n        if (angle >= 0) {\r\n            return angle;\r\n        } else {\r\n            return angle + 2 * Math.PI;\r\n        }\r\n    }\r\n}\r\n","import {Point2} from \"./Point2\";\r\n\r\nexport namespace Point2Math {\r\n\r\n    //@deprecated\r\n    export function offsetPoint({x, y}: Point2, point: Point2): Point2 {\r\n        return {x: x + point.x, y: y + point.y};\r\n    }\r\n\r\n    export function mult(pointA: Point2, scalar:number, output?: Point2): Point2 {\r\n        if(output){\r\n            output.x = pointA.x *scalar;\r\n            output.y = pointA.y *scalar;\r\n            return output;\r\n        }else{\r\n            return {x: pointA.x *scalar, y: pointA.y *scalar};\r\n        }\r\n    }\r\n\r\n    export function floor(pointA: Point2, output?: Point2): Point2 {\r\n        if(output){\r\n            output.x = Math.floor(pointA.x);\r\n            output.y = Math.floor(pointA.y);\r\n            return output;\r\n        }else{\r\n            return {x: Math.floor(pointA.x), y: Math.floor(pointA.y)};\r\n        }\r\n    }\r\n\r\n    export function round(pointA: Point2, output?: Point2): Point2 {\r\n        if(output){\r\n            output.x = Math.round(pointA.x);\r\n            output.y = Math.round(pointA.y);\r\n            return output;\r\n        }else{\r\n            return {x: Math.round(pointA.x), y: Math.round(pointA.y)};\r\n        }\r\n    }\r\n\r\n    export function ceil(pointA: Point2, output?: Point2): Point2 {\r\n        if(output){\r\n            output.x = Math.ceil(pointA.x);\r\n            output.y = Math.ceil(pointA.y);\r\n            return output;\r\n        }else{\r\n            return {x: Math.ceil(pointA.x), y: Math.ceil(pointA.y)};\r\n        }\r\n    }\r\n\r\n    export function add(pointA: Point2, pointB: Point2, output?: Point2): Point2 {\r\n        if(output){\r\n            output.x = pointA.x + pointB.x;\r\n            output.y = pointA.y + pointB.y;\r\n            return output;\r\n        }else{\r\n            return {x: pointA.x + pointB.x, y: pointA.y + pointB.y};\r\n        }\r\n    }\r\n\r\n    export function distance(pointA: Point2, pointB: Point2): number {\r\n        let y = pointB.x - pointA.x;\r\n        let x = pointB.y - pointA.y;\r\n\r\n        return Math.sqrt(x * x + y * y);\r\n    }\r\n\r\n    export function equals(pointA: Point2, pointB: Point2) {\r\n        return pointA.x == pointB.x && pointA.y == pointB.y;\r\n    }\r\n\r\n    export function clone(point: Point2): Point2 {\r\n        return {\r\n            x: point.x,\r\n            y: point.y\r\n        }\r\n    }\r\n}\r\n","import {Area} from \"./Area\";\r\nimport {Point2} from \"./Point2\";\r\nimport { Point2Math } from \"./Point2Math\";\r\n\r\nexport namespace AreaMath {\r\n    export function center(area: Area): Point2 {\r\n        return {\r\n            x: Math.floor((area.from.x + area.to.x) / 2),\r\n            y: Math.floor((area.from.y + area.to.y) / 2),\r\n        }\r\n    }\r\n\r\n    export function size(area: Area): Point2 {\r\n        return {\r\n            x: (area.to.x - area.from.x) +1,\r\n            y: (area.to.y - area.from.y) +1,\r\n        }\r\n    }\r\n\r\n    export function containsPoint(area: Area, point: Point2) {\r\n        return area.from.x <= point.x && point.x <= area.to.x && area.from.y <= point.y && point.y <= area.to.y\r\n    }\r\n\r\n    export function offsetArea({x, y}: Point2, area: Area, output?:Area): Area {\r\n        if(output){\r\n            output.from.x = area.from.x + x;\r\n            output.from.y = area.from.y + y;\r\n            output.to.x = area.to.x + x;\r\n            output.to.y = area.to.y + y;\r\n            return output;\r\n        }else{\r\n            return {\r\n                from: {x: area.from.x + x, y: area.from.y + y},\r\n                to: {x: area.to.x + x, y: area.to.y + y},\r\n            }\r\n        }\r\n    }\r\n\r\n    export function equals(area1: Area, area2: Area): boolean {\r\n        return Point2Math.equals(area1.from, area2.from) && Point2Math.equals(area1.to, area2.to);\r\n    }\r\n\r\n    export function clone(area: Area): Area {\r\n        return {\r\n            from: {\r\n                x: area.from.x,\r\n                y: area.from.y\r\n            },\r\n            to: {\r\n                x: area.to.x,\r\n                y: area.to.y\r\n            }\r\n        };\r\n    }\r\n\r\n    export function forEach(area:Area,callback:(x:number,y:number)=>void,increment=1){\r\n        for (let x = area.from.x; x <= area.to.x; x+=increment) {\r\n            for (let y = area.from.y; y <= area.to.y; y+=increment) {\r\n                callback(x,y);\r\n            }\r\n        }\r\n    }\r\n\r\n    export function mk():Area{\r\n        return {\r\n            from: {\r\n                x: 0,\r\n                y: 0\r\n            },\r\n            to: {\r\n                x: 0,\r\n                y: 0\r\n            }\r\n        }\r\n    }\r\n}\r\n","export const UP = \"up\";\r\nexport const DOWN = \"down\";\r\nexport const RIGHT = \"right\";\r\nexport const LEFT = \"left\";\r\nexport type Direction = \"up\" | \"right\" | \"down\" | \"left\";\r\n","import { Direction, DOWN, LEFT, RIGHT, UP } from \"./Direction\";\r\n\r\nexport namespace DirectionMath {\r\n    export function reverse(inDir: Direction): Direction {\r\n        switch (inDir) {\r\n            case(UP):\r\n                return DOWN;\r\n            case(DOWN):\r\n                return UP;\r\n            case(RIGHT):\r\n                return LEFT;\r\n            case(LEFT):\r\n                return RIGHT;\r\n        }\r\n        throw new Error();\r\n    }\r\n\r\n    export function getAdjacentRightDir(dir): Direction {\r\n        switch (dir) {\r\n            case UP: {\r\n                return RIGHT;\r\n            }\r\n            case DOWN: {\r\n                return LEFT;\r\n            }\r\n            case RIGHT: {\r\n                return DOWN;\r\n            }\r\n            case LEFT: {\r\n                return UP;\r\n            }\r\n        }\r\n        throw new Error();\r\n    }\r\n}\r\n","import {Int} from \"./Int\";\r\n\r\nexport namespace IntMath {\r\n    export function roundToInt(num: number):Int { return Math.round(num) as Int }\r\n}\r\n","import {Direction, DOWN, LEFT, RIGHT, UP} from \"./Direction\";\r\nimport {Point2} from \"./Point2\";\r\n\r\nexport namespace PointDirectionMath {\r\n    export function addInDirection(dir: Direction, value: number, {x, y} = {x: 0, y: 0}): Point2 {\r\n        switch (dir) {\r\n            case(UP as string):\r\n                return {x: x, y: y - value};\r\n            case(DOWN as string):\r\n                return {x: x, y: y + value};\r\n            case(RIGHT as string):\r\n                return {x: x + value, y: y};\r\n            case(LEFT as string):\r\n                return {x: x - value, y};\r\n        }\r\n        throw new Error();\r\n    }\r\n\r\n    export function get4AdjacentDirectionPoint({x, y}, value: number = 1): { point: Point2; direction: Direction }[] {\r\n        let ret = [];\r\n        ret.push({\r\n            direction: UP,\r\n            point: addInDirection(UP, value, {x, y})\r\n        });\r\n        ret.push({\r\n            direction: RIGHT,\r\n            point: addInDirection(RIGHT, value, {x, y})\r\n        });\r\n        ret.push({\r\n            direction: DOWN,\r\n            point: addInDirection(DOWN, value, {x, y})\r\n        });\r\n        ret.push({\r\n            direction: LEFT,\r\n            point: addInDirection(LEFT, value, {x, y})\r\n        });\r\n        return ret;\r\n    }\r\n\r\n    /* reference is UP so if UP is passed as parameters nothing will be rotated*/\r\n    export function rotatePoint({x, y}: Point2, dir: Direction): Point2 {\r\n        //Note clockwize and counter clock wize are inverted since the y axis goes to bottom\r\n        switch (dir) {\r\n            case(UP as string):\r\n                return {x: x, y: y};\r\n            case(DOWN as string)://180 deg\r\n                return {x: -x, y: -y};\r\n            case(RIGHT as string):\r\n                //replace (x,y) with (−y,x). That will rotate 90 degrees counterclockwise about the origin.\r\n                return {x: -y, y: x};\r\n            case(LEFT as string):\r\n                //To rotate clockwise, replace (x,y) with (y,−x).\r\n                return {x: y, y: -x};\r\n        }\r\n        throw new Error();\r\n    }\r\n}\r\n","import {AngleRad} from \"./AngleRad\";\r\nimport {Vector2} from \"./Vector2\";\r\n\r\nexport namespace Vector2Math {\r\n    /**\r\n     *  Rotate this Vector by an angle amount.\r\n     * @param angleRad radian\r\n     * @param vec\r\n     * @param center optional center otherwise {0,0}\r\n     */\r\n    export function rotate(vec: Vector2, angleRad:AngleRad, center?: Vector2): Vector2 {\r\n        //https://stackoverflow.com/questions/17410809/how-to-calculate-rotation-in-2d-in-javascript\r\n        //https://github.com/photonstorm/phaser/blob/v3.51.0/src/math/Vector2.js#L678\r\n        const cos = Math.cos(angleRad);\r\n        const sin = Math.sin(angleRad);\r\n        let x, y;\r\n        if (center) {\r\n            const cx = center.x;\r\n            const cy = center.y;\r\n            x = (cos * (vec.x - cx) - sin * (vec.y - cy));\r\n            y = (sin * (vec.x - cx) + cos * (vec.y - cy));\r\n        } else {\r\n            x = cos * vec.x - sin * vec.y;\r\n            y = sin * vec.x + cos * vec.y;\r\n        }\r\n        vec.x = x;\r\n        vec.y = y;\r\n        return vec;\r\n    }\r\n}\r\n"],"mappings":"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","names":["AngleRadMath","shortestBetween","angleFrom","angleTo","difference","times","normalize","angle","Point2Math","offsetPoint","x","y","point","mult","pointA","scalar","output","floor","round","ceil","add","pointB","distance","equals","clone","AreaMath","center","area","size","containsPoint","point","offsetArea","x","y","output","equals","area1","area2","Point2Math","clone","forEach","callback","increment","mk","UP","DOWN","RIGHT","LEFT","DirectionMath","reverse","inDir","UP","DOWN","RIGHT","LEFT","getAdjacentRightDir","dir","IntMath","roundToInt","num","PointDirectionMath","addInDirection","dir","value","x","y","UP","DOWN","RIGHT","LEFT","get4AdjacentDirectionPoint","ret","rotatePoint","Vector2Math","rotate","vec","angleRad","center","cos","sin","x","y","cx","cy"]}