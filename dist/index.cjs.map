{
  "version": 3,
  "sources": ["../src/index.ts", "../src/AngleRadMath.ts", "../src/Point2Math.ts", "../src/AreaMath.ts", "../src/Direction.ts", "../src/DirectionMath.ts", "../src/IntMath.ts", "../src/PointDirectionMath.ts", "../src/Vector2Math.ts"],
  "sourcesContent": ["export {AngleRad} from \"./AngleRad\"\r\nexport {AngleRadMath} from \"./AngleRadMath\"\r\nexport {Area} from \"./Area\"\r\nexport {AreaMath} from \"./AreaMath\"\r\nexport {Direction,UP,DOWN,LEFT,RIGHT} from \"./Direction\"\r\nexport {DirectionMath} from \"./DirectionMath\"\r\nexport {Int} from \"./Int\"\r\nexport {IntMath} from \"./IntMath\"\r\nexport {Point2} from \"./Point2\"\r\nexport {Point2Math} from \"./Point2Math\"\r\nexport {PointDirectionMath} from \"./PointDirectionMath\"\r\nexport {Vector2Math} from \"./Vector2Math\"\r\nexport {Vector2} from \"./Vector2\"\r\n", "//https://github.com/photonstorm/phaser/tree/v3.55.2/src/math/angle\r\nimport {AngleRad} from \"./AngleRad\";\r\n\r\nexport namespace AngleRadMath {\r\n    /**\r\n     * Gets the shortest angle between `angle1` and `angle2`.\r\n     *\r\n     * Both angles must be in the range -180 to 180, which is the same clamped\r\n     * range that `sprite.angle` uses, so you can pass in two sprite angles to\r\n     * this method and get the shortest angle back between the two of them.\r\n     *\r\n     * The angle returned will be in the same range. If the returned angle is\r\n     * greater than 0 then it's a counter-clockwise rotation, if < 0 then it's\r\n     * a clockwise rotation.\r\n     * @param angleFrom range from -Math.Pi to Pi\r\n     * @param angleTo range from -Math.Pi to Pi\r\n     */\r\n    export function shortestBetween(angleFrom: AngleRad, angleTo: AngleRad) {\r\n        //https://github.com/photonstorm/phaser/blob/v3.55.2/src/math/angle/ShortestBetween.js\r\n        let difference = angleTo - angleFrom;\r\n\r\n        if (difference === 0) {\r\n            return 0;\r\n        }\r\n\r\n        let times = Math.floor((difference - (-Math.PI)) / (Math.PI * 2));\r\n\r\n        return difference - (times * (Math.PI * 2));\r\n    }\r\n\r\n    /**\r\n     * Normalize an angle to the [0, 2pi] range.\r\n     *\r\n     * @function Phaser.Math.Angle.Normalize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} angle - The angle to normalize, in radians.\r\n     *\r\n     * @return {number} The normalized angle, in radians.\r\n     */\r\n    export function normalize(angle: AngleRad): AngleRad {\r\n        //https://github.com/photonstorm/phaser/blob/v3.55.2/src/math/angle/Normalize.js\r\n        angle = angle % (2 * Math.PI);\r\n\r\n        if (angle >= 0) {\r\n            return angle;\r\n        } else {\r\n            return angle + 2 * Math.PI;\r\n        }\r\n    }\r\n}\r\n", "import {Point2} from \"./Point2\";\r\n\r\nexport namespace Point2Math {\r\n\r\n    //@deprecated\r\n    export function offsetPoint({x, y}: Point2, point: Point2): Point2 {\r\n        return {x: x + point.x, y: y + point.y};\r\n    }\r\n\r\n    export function mult(pointA: Point2, scalar:number, output?: Point2): Point2 {\r\n        if(output){\r\n            output.x = pointA.x *scalar;\r\n            output.y = pointA.y *scalar;\r\n            return output;\r\n        }else{\r\n            return {x: pointA.x *scalar, y: pointA.y *scalar};\r\n        }\r\n    }\r\n\r\n    export function floor(pointA: Point2, output?: Point2): Point2 {\r\n        if(output){\r\n            output.x = Math.floor(pointA.x);\r\n            output.y = Math.floor(pointA.y);\r\n            return output;\r\n        }else{\r\n            return {x: Math.floor(pointA.x), y: Math.floor(pointA.y)};\r\n        }\r\n    }\r\n\r\n    export function round(pointA: Point2, output?: Point2): Point2 {\r\n        if(output){\r\n            output.x = Math.round(pointA.x);\r\n            output.y = Math.round(pointA.y);\r\n            return output;\r\n        }else{\r\n            return {x: Math.round(pointA.x), y: Math.round(pointA.y)};\r\n        }\r\n    }\r\n\r\n    export function ceil(pointA: Point2, output?: Point2): Point2 {\r\n        if(output){\r\n            output.x = Math.ceil(pointA.x);\r\n            output.y = Math.ceil(pointA.y);\r\n            return output;\r\n        }else{\r\n            return {x: Math.ceil(pointA.x), y: Math.ceil(pointA.y)};\r\n        }\r\n    }\r\n\r\n    export function add(pointA: Point2, pointB: Point2, output?: Point2): Point2 {\r\n        if(output){\r\n            output.x = pointA.x + pointB.x;\r\n            output.y = pointA.y + pointB.y;\r\n            return output;\r\n        }else{\r\n            return {x: pointA.x + pointB.x, y: pointA.y + pointB.y};\r\n        }\r\n    }\r\n\r\n    export function distance(pointA: Point2, pointB: Point2): number {\r\n        let y = pointB.x - pointA.x;\r\n        let x = pointB.y - pointA.y;\r\n\r\n        return Math.sqrt(x * x + y * y);\r\n    }\r\n\r\n    export function equals(pointA: Point2, pointB: Point2) {\r\n        return pointA.x == pointB.x && pointA.y == pointB.y;\r\n    }\r\n\r\n    export function clone(point: Point2): Point2 {\r\n        return {\r\n            x: point.x,\r\n            y: point.y\r\n        }\r\n    }\r\n}\r\n", "import {Area} from \"./Area\";\r\nimport {Point2} from \"./Point2\";\r\nimport { Point2Math } from \"./Point2Math\";\r\n\r\nexport namespace AreaMath {\r\n    export function center(area: Area): Point2 {\r\n        return {\r\n            x: Math.floor((area.from.x + area.to.x) / 2),\r\n            y: Math.floor((area.from.y + area.to.y) / 2),\r\n        }\r\n    }\r\n\r\n    export function size(area: Area): Point2 {\r\n        return {\r\n            x: (area.to.x - area.from.x) +1,\r\n            y: (area.to.y - area.from.y) +1,\r\n        }\r\n    }\r\n\r\n    export function containsPoint(area: Area, point: Point2) {\r\n        return area.from.x <= point.x && point.x <= area.to.x && area.from.y <= point.y && point.y <= area.to.y\r\n    }\r\n\r\n    export function offsetArea({x, y}: Point2, area: Area, output?:Area): Area {\r\n        if(output){\r\n            output.from.x = area.from.x + x;\r\n            output.from.y = area.from.y + y;\r\n            output.to.x = area.to.x + x;\r\n            output.to.y = area.to.y + y;\r\n            return output;\r\n        }else{\r\n            return {\r\n                from: {x: area.from.x + x, y: area.from.y + y},\r\n                to: {x: area.to.x + x, y: area.to.y + y},\r\n            }\r\n        }\r\n    }\r\n\r\n    export function equals(area1: Area, area2: Area): boolean {\r\n        return Point2Math.equals(area1.from, area2.from) && Point2Math.equals(area1.to, area2.to);\r\n    }\r\n\r\n    export function clone(area: Area): Area {\r\n        return {\r\n            from: {\r\n                x: area.from.x,\r\n                y: area.from.y\r\n            },\r\n            to: {\r\n                x: area.to.x,\r\n                y: area.to.y\r\n            }\r\n        };\r\n    }\r\n\r\n    export function forEach(area:Area,callback:(x:number,y:number)=>void,increment=1){\r\n        for (let x = area.from.x; x <= area.to.x; x+=increment) {\r\n            for (let y = area.from.y; y <= area.to.y; y+=increment) {\r\n                callback(x,y);\r\n            }\r\n        }\r\n    }\r\n\r\n    export function mk():Area{\r\n        return {\r\n            from: {\r\n                x: 0,\r\n                y: 0\r\n            },\r\n            to: {\r\n                x: 0,\r\n                y: 0\r\n            }\r\n        }\r\n    }\r\n}\r\n", "export const UP = \"up\";\r\nexport const DOWN = \"down\";\r\nexport const RIGHT = \"right\";\r\nexport const LEFT = \"left\";\r\nexport type Direction = \"up\" | \"right\" | \"down\" | \"left\";\r\n", "import { Direction, DOWN, LEFT, RIGHT, UP } from \"./Direction\";\r\n\r\nexport namespace DirectionMath {\r\n    export function reverse(inDir: Direction): Direction {\r\n        switch (inDir) {\r\n            case(UP):\r\n                return DOWN;\r\n            case(DOWN):\r\n                return UP;\r\n            case(RIGHT):\r\n                return LEFT;\r\n            case(LEFT):\r\n                return RIGHT;\r\n        }\r\n        throw new Error();\r\n    }\r\n\r\n    export function getAdjacentRightDir(dir): Direction {\r\n        switch (dir) {\r\n            case UP: {\r\n                return RIGHT;\r\n            }\r\n            case DOWN: {\r\n                return LEFT;\r\n            }\r\n            case RIGHT: {\r\n                return DOWN;\r\n            }\r\n            case LEFT: {\r\n                return UP;\r\n            }\r\n        }\r\n        throw new Error();\r\n    }\r\n}\r\n", "import {Int} from \"./Int\";\r\n\r\nexport namespace IntMath {\r\n    export function roundToInt(num: number):Int { return Math.round(num) as Int }\r\n}\r\n", "import {Direction, DOWN, LEFT, RIGHT, UP} from \"./Direction\";\r\nimport {Point2} from \"./Point2\";\r\n\r\nexport namespace PointDirectionMath {\r\n    export function addInDirection(dir: Direction, value: number, {x, y} = {x: 0, y: 0}): Point2 {\r\n        switch (dir) {\r\n            case(UP as string):\r\n                return {x: x, y: y - value};\r\n            case(DOWN as string):\r\n                return {x: x, y: y + value};\r\n            case(RIGHT as string):\r\n                return {x: x + value, y: y};\r\n            case(LEFT as string):\r\n                return {x: x - value, y};\r\n        }\r\n        throw new Error();\r\n    }\r\n\r\n    export function get4AdjacentDirectionPoint({x, y}, value: number = 1): { point: Point2; direction: Direction }[] {\r\n        let ret = [];\r\n        ret.push({\r\n            direction: UP,\r\n            point: addInDirection(UP, value, {x, y})\r\n        });\r\n        ret.push({\r\n            direction: RIGHT,\r\n            point: addInDirection(RIGHT, value, {x, y})\r\n        });\r\n        ret.push({\r\n            direction: DOWN,\r\n            point: addInDirection(DOWN, value, {x, y})\r\n        });\r\n        ret.push({\r\n            direction: LEFT,\r\n            point: addInDirection(LEFT, value, {x, y})\r\n        });\r\n        return ret;\r\n    }\r\n\r\n    /* reference is UP so if UP is passed as parameters nothing will be rotated*/\r\n    export function rotatePoint({x, y}: Point2, dir: Direction): Point2 {\r\n        //Note clockwize and counter clock wize are inverted since the y axis goes to bottom\r\n        switch (dir) {\r\n            case(UP as string):\r\n                return {x: x, y: y};\r\n            case(DOWN as string)://180 deg\r\n                return {x: -x, y: -y};\r\n            case(RIGHT as string):\r\n                //replace (x,y) with (\u2212y,x). That will rotate 90 degrees counterclockwise about the origin.\r\n                return {x: -y, y: x};\r\n            case(LEFT as string):\r\n                //To rotate clockwise, replace (x,y) with (y,\u2212x).\r\n                return {x: y, y: -x};\r\n        }\r\n        throw new Error();\r\n    }\r\n}\r\n", "import {AngleRad} from \"./AngleRad\";\r\nimport {Vector2} from \"./Vector2\";\r\n\r\nexport namespace Vector2Math {\r\n    /**\r\n     *  Rotate this Vector by an angle amount.\r\n     * @param angleRad radian\r\n     * @param vec\r\n     * @param center optional center otherwise {0,0}\r\n     */\r\n    export function rotate(vec: Vector2, angleRad:AngleRad, center?: Vector2): Vector2 {\r\n        //https://stackoverflow.com/questions/17410809/how-to-calculate-rotation-in-2d-in-javascript\r\n        //https://github.com/photonstorm/phaser/blob/v3.51.0/src/math/Vector2.js#L678\r\n        const cos = Math.cos(angleRad);\r\n        const sin = Math.sin(angleRad);\r\n        let x, y;\r\n        if (center) {\r\n            const cx = center.x;\r\n            const cy = center.y;\r\n            x = (cos * (vec.x - cx) - sin * (vec.y - cy));\r\n            y = (sin * (vec.x - cx) + cos * (vec.y - cy));\r\n        } else {\r\n            x = cos * vec.x - sin * vec.y;\r\n            y = sin * vec.x + cos * vec.y;\r\n        }\r\n        vec.x = x;\r\n        vec.y = y;\r\n        return vec;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["AngleRadMath", "Point2Math", "AreaMath", "DirectionMath", "IntMath", "PointDirectionMath", "Vector2Math"]
}
